// app.js
import { db, auth } from "./firebase.js";
import { 
    collection, 
    addDoc, 
    getDocs, 
    doc, 
    updateDoc, 
    getDoc,
    setDoc,
    query,
    where,
    arrayUnion,
    arrayRemove,
    orderBy
} from "https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js";
import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";

class CheckIceApp {
    constructor() {
        this.currentUser = null;
        this.currentTab = 'map';
        this.userStats = {
            points: 0,
            level: 1,
            visitedRinks: 0,
            friends: 0
        };
        
        this.userPosition = null;
        this.nearbyRinks = [];
        this.allRinks = [];
        this.isGeolocationEnabled = false;
        this.isLoadingChecklist = false;
        
        this.init();
    }

    async init() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupApp());
        } else {
            this.setupApp();
        }
    }

    setupApp() {
        this.setupTabs();
        this.setupChecklist();
        this.setupNotifications();
        this.setupPointsSystem();
        this.setupGeolocation();
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                this.currentUser = user;
                this.loadUserData();
            } else {
                window.location.href = "/checkice/login.html";
            }
        });
    }

    // === GESTION DES ONGLETS ===
    setupTabs() {
        const tabButtons = document.querySelectorAll('.tab-button');
        const contentSections = document.querySelectorAll('.content-section');

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetTab = button.getAttribute('data-tab');
                this.switchTab(targetTab, tabButtons, contentSections);
            });
        });
    }

    switchTab(targetTab, tabButtons, contentSections) {
        tabButtons.forEach(btn => btn.classList.remove('tab-active'));
        contentSections.forEach(section => section.classList.remove('active'));

        const activeButton = document.querySelector(`[data-tab="${targetTab}"]`);
        const activeSection = document.getElementById(`${targetTab}-section`);

        if (activeButton && activeSection) {
            activeButton.classList.add('tab-active');
            activeSection.classList.add('active');
            this.currentTab = targetTab;
        }
    }

    setupChecklist() {
        console.log('üîß DEBUG: setupChecklist() - Configuration des √©v√©nements');
        
        document.addEventListener('click', (e) => {
            if (e.target.closest('.check-circle') || e.target.closest('.check-circle-dynamic')) {
                const checklistItem = e.target.closest('.checklist-item') || e.target.closest('.checklist-item-dynamic');
                if (checklistItem) {
                    const rinkId = checklistItem.getAttribute('data-rink-id');
                    if (rinkId) {
                        const rink = this.nearbyRinks.find(r => r.id === rinkId);
                        if (rink) {
                            this.toggleEnhancedChecklistItem(rink, checklistItem);
                        }
                    }
                }
            }
        });
    }

    async loadChecklist() {
        console.log('üîç DEBUG: D√©but loadChecklist()');
        
        if (!this.currentUser) {
            console.log('‚ùå DEBUG: Pas d\'utilisateur connect√©');
            return;
        }

        if (this.isLoadingChecklist) {
            console.log('‚ö†Ô∏è DEBUG: Chargement d√©j√† en cours, ignor√©');
            return;
        }
        this.isLoadingChecklist = true;
        
        console.log('‚úÖ DEBUG: Utilisateur connect√©:', this.currentUser.uid);

        try {
            const checklistContainer = document.querySelector('#check-section .space-y-4');
            console.log('üì¶ DEBUG: Container checklist trouv√©:', !!checklistContainer);
            
            if (!checklistContainer) {
                console.log('‚ùå DEBUG: Container checklist introuvable !');
                return;
            }

            this.showLoadingMessage(checklistContainer);

            console.log('üîÑ DEBUG: Chargement des patinoires depuis Firebase...');
            await this.loadAllRinksFromFirebase();
            
            if (this.nearbyRinks.length === 0) {
                console.log('‚ö†Ô∏è DEBUG: Aucune patinoire trouv√©e dans Firebase');
                this.showNoRinksMessage(checklistContainer);
                return;
            }

            console.log(`üìä DEBUG: ${this.nearbyRinks.length} patinoires charg√©es depuis Firebase`);

            // Charger les donn√©es utilisateur
            const userDoc = await getDoc(doc(db, "users", this.currentUser.uid));
            const userData = userDoc.exists() ? userDoc.data() : {};
            const visitedRinks = userData.visitedRinks || [];
            
            console.log(`üìä DEBUG: Patinoires visit√©es: ${visitedRinks.length}`);

            this.userStats.points = userData.points || 0;
            this.userStats.level = userData.level || 1;
            this.userStats.visitedRinks = visitedRinks.length;

            // Marquer les patinoires visit√©es
            this.nearbyRinks.forEach(rink => {
                rink.visited = visitedRinks.includes(rink.id);
            });

            const sortedRinks = this.sortRinksBySections(this.nearbyRinks);
            
            console.log(`üìä DEBUG: Patinoires √† afficher: ${sortedRinks.length}`);
            console.log('üìä DEBUG: D√©tail des patinoires:', sortedRinks.map(r => `${r.name} (${r.visited ? 'visit√©e' : '√† d√©couvrir'})`));

            this.displayDynamicChecklist(sortedRinks);
            this.updateStatsDisplay();
            
            console.log('‚úÖ DEBUG: loadChecklist() termin√©');
            
        } catch (error) {
            console.error('‚ùå DEBUG: Erreur dans loadChecklist():', error);
            const checklistContainer = document.querySelector('#check-section .space-y-4');
            if (checklistContainer) {
                this.showErrorMessage(checklistContainer, error.message);
            }
        } finally {
            this.isLoadingChecklist = false;
        }
    }

    showLoadingMessage(container) {
        const header = container.querySelector('h2');
        container.innerHTML = '';
        if (header) container.appendChild(header);
        
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'text-center py-8';
        loadingDiv.innerHTML = `
            <div class="inline-flex items-center space-x-3">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                <span class="text-blue-600 font-medium">Chargement des patinoires depuis Firebase...</span>
            </div>
        `;
        container.appendChild(loadingDiv);
    }

    showNoRinksMessage(container) {
        const header = container.querySelector('h2');
        container.innerHTML = '';
        if (header) container.appendChild(header);
        
        const noRinksDiv = document.createElement('div');
        noRinksDiv.className = 'text-center py-12';
        noRinksDiv.innerHTML = `
            <div class="text-gray-500">
                <div class="text-6xl mb-4">üèí</div>
                <h3 class="text-xl font-semibold mb-2">Aucune patinoire disponible</h3>
                <p class="text-sm">Les patinoires seront ajout√©es dans la base de donn√©es Firebase.</p>
                <button onclick="window.checkIceApp.loadChecklist()" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    üîÑ Actualiser
                </button>
            </div>
        `;
        container.appendChild(noRinksDiv);
    }

    showErrorMessage(container, errorMsg) {
        const header = container.querySelector('h2');
        container.innerHTML = '';
        if (header) container.appendChild(header);
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'text-center py-12';
        errorDiv.innerHTML = `
            <div class="text-red-500">
                <div class="text-4xl mb-4">‚ö†Ô∏è</div>
                <h3 class="text-xl font-semibold mb-2">Erreur de chargement</h3>
                <p class="text-sm mb-4">${errorMsg}</p>
                <button onclick="window.checkIceApp.loadChecklist()" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                    üîÑ R√©essayer
                </button>
            </div>
        `;
        container.appendChild(errorDiv);
    }

    async loadAllRinksFromFirebase() {
        console.log('üîÑ Chargement dynamique des patinoires depuis Firebase...');
        
        try {
            const rinksCollection = collection(db, "rinks");
            const rinksSnapshot = await getDocs(rinksCollection);
            
            this.allRinks = [];
            this.nearbyRinks = [];
            
            if (rinksSnapshot.empty) {
                console.log('üì≠ Collection "rinks" vide dans Firebase');
                return;
            }
            
            rinksSnapshot.forEach((doc) => {
                const rinkData = doc.data();
                console.log(`üìç Patinoire trouv√©e: ${rinkData.name || 'Sans nom'}`);
                
                if (rinkData.name) {
                    let lat = 0, lng = 0;
                    
                    if (rinkData.coordinates && Array.isArray(rinkData.coordinates)) {
                        lat = parseFloat(rinkData.coordinates[0]) || 0;
                        lng = parseFloat(rinkData.coordinates[1]) || 0;
                    } else if (rinkData.lat && rinkData.lng) {
                        lat = parseFloat(rinkData.lat) || 0;
                        lng = parseFloat(rinkData.lng) || 0;
                    } else if (rinkData.latitude && rinkData.longitude) {
                        lat = parseFloat(rinkData.latitude) || 0;
                        lng = parseFloat(rinkData.longitude) || 0;
                    }
                    
                    const rink = {
                        id: doc.id,
                        name: rinkData.name,
                        city: rinkData.city || rinkData.ville || 'Ville inconnue',
                        address: rinkData.address || rinkData.adresse || '',
                        lat: lat,
                        lng: lng,
                        visited: false,
                        status: rinkData.status || 'Inconnue',
                        ice_quality: rinkData.ice_quality || '',
                        phone: rinkData.phone || '',
                        website: rinkData.website || ''
                    };
                    
                    this.allRinks.push(rink);
                    console.log(`‚úÖ Patinoire ajout√©e: ${rink.name} (${lat}, ${lng})`);
                }
            });
            
            console.log(`‚úÖ ${this.allRinks.length} patinoires charg√©es depuis Firebase`);
            
            if (this.isGeolocationEnabled && this.userPosition) {
                await this.calculateDistances();
            } else {
                this.nearbyRinks = [...this.allRinks];
            }
            
        } catch (error) {
            console.error('‚ùå Erreur lors du chargement depuis Firebase:', error);
            throw error;
        }
    }

    sortRinksBySections(rinks) {
        console.log('üî§ DEBUG: Tri alphab√©tique par sections');
        
        if (!rinks || !Array.isArray(rinks) || rinks.length === 0) {
            console.log('‚ö†Ô∏è DEBUG: Liste de patinoires vide ou invalide');
            return [];
        }
        
        const unvisited = rinks.filter(rink => !rink.visited);
        const visited = rinks.filter(rink => rink.visited);
        
        const sortAlphabetically = (a, b) => a.name.localeCompare(b.name, 'fr');
        
        unvisited.sort(sortAlphabetically);
        visited.sort(sortAlphabetically);
        
        console.log(`üìä Non visit√©es: ${unvisited.length}, Visit√©es: ${visited.length}`);
        
        return [...unvisited, ...visited];
    }

    displayDynamicChecklist(rinks) {
        console.log('üîç DEBUG: D√©but displayDynamicChecklist()');
        console.log(`üìä DEBUG: Nombre de patinoires re√ßues: ${rinks.length}`);
        
        if (!rinks || !Array.isArray(rinks)) {
            console.error('‚ùå DEBUG: rinks n\'est pas un tableau valide:', rinks);
            rinks = [];
        }
        
        const checklistContainer = document.querySelector('#check-section .space-y-4');
        console.log('üìä DEBUG: Container trouv√©:', !!checklistContainer);
        
        if (!checklistContainer) {
            console.log('‚ùå DEBUG: Container checklist non trouv√© !');
            return;
        }

        // Garder seulement le header principal
        const mainHeader = checklistContainer.querySelector('h2');
        console.log('üìä DEBUG: Header principal trouv√©:', !!mainHeader);
        
        checklistContainer.innerHTML = '';
        if (mainHeader) {
            checklistContainer.appendChild(mainHeader);
            console.log('‚úÖ DEBUG: Header principal restaur√©');
        }

        if (rinks.length === 0) {
            console.log('‚ö†Ô∏è DEBUG: Aucune patinoire √† afficher');
            this.showNoRinksMessage(checklistContainer);
            return;
        }

        // S√©parer les patinoires par section
        const unvisitedRinks = rinks.filter(rink => !rink.visited);
        const visitedRinks = rinks.filter(rink => rink.visited);
        
        console.log(`üìä DEBUG: ${unvisitedRinks.length} √† d√©couvrir, ${visitedRinks.length} visit√©es`);

        // SECTION 1: PATINOIRES √Ä D√âCOUVRIR
        if (unvisitedRinks.length > 0) {
            const toVisitSection = document.createElement('div');
            toVisitSection.className = 'mb-8';
            
            const toVisitHeader = document.createElement('div');
            toVisitHeader.className = 'flex items-center mb-6';
            toVisitHeader.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full flex items-center justify-center">
                        <span class="text-white font-bold text-sm">üéØ</span>
                    </div>
                    <h3 class="text-xl font-bold text-gray-800">√Ä d√©couvrir</h3>
                    <span class="bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full">${unvisitedRinks.length}</span>
                </div>
            `;
            
            toVisitSection.appendChild(toVisitHeader);
            
            const toVisitList = document.createElement('div');
            toVisitList.className = 'space-y-4';
            
            unvisitedRinks.forEach((rink, index) => {
                console.log(`‚ûï DEBUG: Cr√©ation item √† d√©couvrir ${index + 1}: ${rink.name}`);
                const checklistItem = this.createEnhancedChecklistItem(rink, index);
                toVisitList.appendChild(checklistItem);
            });
            
            toVisitSection.appendChild(toVisitList);
            checklistContainer.appendChild(toVisitSection);
        }

        // SECTION 2: PATINOIRES VISIT√âES
        if (visitedRinks.length > 0) {
            const visitedSection = document.createElement('div');
            visitedSection.className = 'mt-8';
            
            const visitedHeader = document.createElement('div');
            visitedHeader.className = 'flex items-center mb-6';
            visitedHeader.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-gradient-to-r from-green-500 to-green-600 rounded-full flex items-center justify-center">
                        <span class="text-white font-bold text-sm">‚úì</span>
                    </div>
                    <h3 class="text-xl font-bold text-gray-800">Visit√©es</h3>
                    <span class="bg-green-100 text-green-800 text-xs font-semibold px-2.5 py-0.5 rounded-full">${visitedRinks.length}</span>
                </div>
            `;
            
            visitedSection.appendChild(visitedHeader);
            
            const visitedList = document.createElement('div');
            visitedList.className = 'space-y-4';
            
            visitedRinks.forEach((rink, index) => {
                console.log(`‚ûï DEBUG: Cr√©ation item visit√© ${index + 1}: ${rink.name}`);
                const checklistItem = this.createEnhancedChecklistItem(rink, index + unvisitedRinks.length);
                visitedList.appendChild(checklistItem);
            });
            
            visitedSection.appendChild(visitedList);
            checklistContainer.appendChild(visitedSection);
        }

        // MESSAGE SI AUCUNE PATINOIRE VISIT√âE
        if (unvisitedRinks.length > 0 && visitedRinks.length === 0) {
            const encouragementDiv = document.createElement('div');
            encouragementDiv.className = 'mt-8 text-center py-8 bg-gradient-to-r from-blue-50 to-green-50 rounded-xl border-2 border-dashed border-blue-200';
            encouragementDiv.innerHTML = `
                <div class="text-gray-600">
                    <div class="text-4xl mb-3">üèí</div>
                    <h4 class="text-lg font-semibold mb-2">Premi√®re visite ?</h4>
                    <p class="text-sm">Cliquez sur une patinoire ci-dessus pour commencer votre collection !</p>
                </div>
            `;
            checklistContainer.appendChild(encouragementDiv);
        }

        console.log('‚úÖ DEBUG: Sections cr√©√©es');
        
        setTimeout(() => {
            console.log('üé® DEBUG: Animation des items');
            this.animateChecklistItems();
        }, 100);
        
        console.log('‚úÖ DEBUG: displayDynamicChecklist() termin√©');
    }

    createEnhancedChecklistItem(rink, index) {
        const item = document.createElement('div');
        item.className = `checklist-item-dynamic rounded-xl p-4 flex items-center transition-all duration-300 ${rink.visited ? 'checked' : ''}`;
        item.setAttribute('data-rink-id', rink.id);
        item.setAttribute('data-points', '50');
        item.style.animationDelay = `${index * 0.1}s`;

        const distanceText = rink.distance && this.isGeolocationEnabled ? 
            `${rink.distance < 1 ? Math.round(rink.distance * 1000) + 'm' : rink.distance.toFixed(1) + 'km'}` : 
            '';

        item.innerHTML = `
            <div class="check-circle-dynamic relative">
                <div class="w-12 h-12 rounded-full border-3 ${rink.visited ? 'border-green-400 bg-green-50' : 'border-blue-200 bg-white'} flex items-center justify-center cursor-pointer transition-all duration-300 hover:scale-110">
                    ${rink.visited ? 
                        '<div class="w-6 h-6 bg-gradient-to-r from-green-500 to-green-600 rounded-full flex items-center justify-center text-white text-xs font-bold">‚úì</div>' :
                        '<div class="w-6 h-6 border-2 border-gray-300 rounded-full hover:border-blue-400 transition-all duration-300"></div>'
                    }
                </div>
                ${!rink.visited ? `
                    <div class="absolute -top-2 -right-2 points-badge-dynamic text-xs font-bold px-2 py-1 rounded-full text-white shadow-lg">
                        +50
                    </div>
                ` : ''}
            </div>

            <div class="flex-1 ml-4">
                <h3 class="font-semibold text-gray-800 text-lg">${rink.name}</h3>
                <div class="flex items-center space-x-3 mt-1">
                    <span class="text-sm font-medium ${rink.visited ? 'text-green-600' : 'text-blue-600'}">
                        ${rink.visited ? '‚úì Visit√©e' : '√Ä d√©couvrir'}
                    </span>
                    <span class="text-sm text-gray-500">‚Ä¢ ${rink.city}</span>
                    ${distanceText ? `<span class="text-sm text-blue-600 font-medium distance-indicator">üìç ${distanceText}</span>` : ''}
                </div>
                ${rink.address ? `<div class="text-xs text-gray-400 mt-1">üìç ${rink.address}</div>` : ''}
            </div>

            ${rink.visited ? `
                <div class="flex items-center space-x-2 text-green-600">
                    <div class="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
                        <span class="text-sm font-bold">‚úì</span>
                    </div>
                </div>
            ` : ''}
        `;

        return item;
    }

    // ‚úÖ VERSION S√âCURIS√âE avec gestion d'erreurs compl√®te
    async toggleEnhancedChecklistItem(rink, itemElement) {
        try {
            console.log('üéØ Toggle patinoire:', rink.name, 'visit√©e:', rink.visited);
            
            const checkCircle = itemElement.querySelector('.check-circle-dynamic');
            const pointsBadge = itemElement.querySelector('.points-badge-dynamic');
            
            // Animation du clic
            checkCircle.style.transition = 'all 0.15s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
            checkCircle.style.transform = 'scale(1.1)';
            
            setTimeout(() => {
                checkCircle.style.transform = 'scale(1)';
            }, 150);

            if (pointsBadge && !rink.visited) {
                pointsBadge.style.animation = 'pointsEarned 0.3s ease-out';
            }
            
            const wasVisited = rink.visited;
            const nowVisited = !wasVisited;
            
            console.log(`üìù Changement d'√©tat: ${wasVisited} ‚Üí ${nowVisited}`);
            
            // SAUVEGARDE FIREBASE EN PARALL√àLE
            const savePromises = [];
            
            if (nowVisited) {
                // Marquer comme visit√©e
                savePromises.push(this.markRinkAsVisited(rink.id));
                savePromises.push(this.updateUserStats(50));
                this.showNotification(`üéâ +50 points ! ${rink.name} visit√©e !`, 'success');
            } else {
                // D√©marquer comme visit√©e
                savePromises.push(this.unmarkRinkAsVisited(rink.id));
                savePromises.push(this.updateUserStats(-50));
                this.showNotification(`‚¨ÖÔ∏è -50 points ! ${rink.name} d√©coch√©e`, 'info');
            }
            
            // ATTENDRE LA SAUVEGARDE AVANT DE CONTINUER
            await Promise.all(savePromises);
            
            // Mettre √† jour l'√©tat local seulement APR√àS succ√®s Firebase
            rink.visited = nowVisited;
            
            if (nowVisited) {
                itemElement.classList.add('checked');
            } else {
                itemElement.classList.remove('checked');
            }
            
            // ATTENDRE AVANT R√âORGANISATION
            setTimeout(async () => {
                console.log(`üé¨ D√©but r√©organisation: ${rink.name}`);
                
                itemElement.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                itemElement.style.opacity = '0';
                itemElement.style.transform = 'translateX(-20px)';
                
                setTimeout(() => {
                    this.reorganizeChecklist();
                }, 300);
                
            }, 500);
            
        } catch (error) {
            console.error('‚ùå Erreur toggle patinoire:', error);
            this.showNotification('Erreur lors de la sauvegarde. Veuillez r√©essayer.', 'error');
            
            // ANNULER LES CHANGEMENTS EN CAS D'ERREUR
            await this.loadChecklist();
        }
    }

    // ‚úÖ VERSION CORRIG√âE avec arrayUnion pour √©viter les doublons
    async markRinkAsVisited(rinkId) {
        const user = this.currentUser;
        if (!user) {
            console.error('‚ùå Utilisateur non connect√©');
            return;
        }

        try {
            console.log('üíæ Sauvegarde visite patinoire:', rinkId);
            
            const userDocRef = doc(db, "users", user.uid);
            
            // UTILISER arrayUnion pour √©viter les doublons automatiquement
            await updateDoc(userDocRef, {
                visitedRinks: arrayUnion(rinkId),
                lastVisit: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            });
            
            console.log('‚úÖ Visite sauvegard√©e avec succ√®s:', rinkId);
            
            // V√âRIFICATION : Relire pour confirmer la sauvegarde
            const updatedDoc = await getDoc(userDocRef);
            if (updatedDoc.exists()) {
                const updatedData = updatedDoc.data();
                console.log('üìä visitedRinks apr√®s sauvegarde:', updatedData.visitedRinks || []);
            }
            
        } catch (error) {
            console.error('‚ùå Erreur sauvegarde visite:', error);
            throw error;
        }
    }

    // ‚úÖ VERSION CORRIG√âE avec arrayRemove
    async unmarkRinkAsVisited(rinkId) {
        const user = this.currentUser;
        if (!user) {
            console.error('‚ùå Utilisateur non connect√©');
            return;
        }

        try {
            console.log('üóëÔ∏è Suppression visite patinoire:', rinkId);
            
            const userDocRef = doc(db, "users", user.uid);
            
            // UTILISER arrayRemove pour supprimer
            await updateDoc(userDocRef, {
                visitedRinks: arrayRemove(rinkId),
                lastVisit: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            });
            
            console.log('‚úÖ Visite supprim√©e avec succ√®s:', rinkId);
            
        } catch (error) {
            console.error('‚ùå Erreur suppression visite:', error);
            throw error;
        }
    }

    async reorganizeChecklist() {
        console.log('üîÑ R√©organisation de la checklist...');
        
        try {
            const userDoc = await getDoc(doc(db, "users", this.currentUser.uid));
            const userData = userDoc.exists() ? userDoc.data() : {};
            const visitedRinks = userData.visitedRinks || [];
            
            this.nearbyRinks.forEach(rink => {
                rink.visited = visitedRinks.includes(rink.id);
            });

            const sortedRinks = this.sortRinksBySections(this.nearbyRinks);
            this.displayDynamicChecklist(sortedRinks);
            
            console.log('‚úÖ R√©organisation termin√©e');
            
        } catch (error) {
            console.error('‚ùå Erreur r√©organisation:', error);
        }
    }

    async updateUserStats(pointsChange) {
        const user = this.currentUser;
        if (!user) return;

        try {
            this.userStats.points = Math.max(0, this.userStats.points + pointsChange);
            this.userStats.level = Math.floor(this.userStats.points / 200) + 1;
            this.updateStatsDisplay();
            
            const userDocRef = doc(db, "users", user.uid);
            const userSnap = await getDoc(userDocRef);
            
            const currentData = userSnap.exists() ? userSnap.data() : {};
            const newPoints = Math.max(0, (currentData.points || 0) + pointsChange);
            const newLevel = Math.floor(newPoints / 200) + 1;
            
            await updateDoc(userDocRef, {
                points: newPoints,
                level: newLevel,
                updatedAt: new Date().toISOString()
            });
            
            if (newLevel > (currentData.level || 1)) {
                setTimeout(() => {
                    this.showNotification(`üéä Niveau ${newLevel} atteint !`, 'success');
                }, 500);
            } else if (newLevel < (currentData.level || 1)) {
                setTimeout(() => {
                    this.showNotification(`üìâ Niveau ${newLevel}`, 'info');
                }, 500);
            }
            
        } catch (error) {
            console.error('‚ùå Erreur mise √† jour stats:', error);
        }
    }

    animateChecklistItems() {
        console.log('üé® DEBUG: Animation des items');
        const items = document.querySelectorAll('.checklist-item-dynamic');
        items.forEach((item, index) => {
            setTimeout(() => {
                item.style.opacity = '1';
                item.style.transform = 'translateY(0)';
            }, index * 50);
        });
    }

    setupGeolocation() {
        console.log('üîß Setup g√©olocalisation...');
        
        const geoButton = document.querySelector('#enable-geolocation');
        if (geoButton) {
            geoButton.addEventListener('click', () => {
                this.getUserLocation();
            });
        }
        
        if (navigator.geolocation) {
            this.getUserLocation();
        }
    }

    async getUserLocation() {
        console.log('üìç Demande de g√©olocalisation...');
        
        if (!navigator.geolocation) {
            console.log('‚ùå G√©olocalisation non support√©e');
            return;
        }

        try {
            const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 300000
                });
            });

            this.userPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            
            this.isGeolocationEnabled = true;
            console.log('‚úÖ Position obtenue:', this.userPosition);
            
            if (this.allRinks.length > 0) {
                await this.calculateDistances();
                await this.loadChecklist();
            }
            
        } catch (error) {
            console.error('‚ùå Erreur g√©olocalisation:', error);
            this.isGeolocationEnabled = false;
        }
    }

    async calculateDistances() {
        if (!this.userPosition || this.allRinks.length === 0) return;
        
        console.log('üìè Calcul des distances...');
        
        this.nearbyRinks = this.allRinks.map(rink => {
            const distance = this.calculateDistance(
                this.userPosition.lat,
                this.userPosition.lng,
                rink.lat,
                rink.lng
            );
            
            return {
                ...rink,
                distance: distance
            };
        });
        
        this.nearbyRinks.sort((a, b) => a.distance - b.distance);
        
        console.log(`‚úÖ ${this.nearbyRinks.length} patinoires avec distances calcul√©es`);
    }

    calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    async loadUserData() {
        console.log('üë§ Chargement donn√©es utilisateur...');
        
        if (!this.currentUser) return;
        
        try {
            const userDocRef = doc(db, "users", this.currentUser.uid);
            const userSnap = await getDoc(userDocRef);
            
            if (userSnap.exists()) {
                const userData = userSnap.data();
                this.userStats = {
                    points: userData.points || 0,
                    level: userData.level || 1,
                    visitedRinks: (userData.visitedRinks || []).length,
                    friends: userData.friends?.length || 0
                };
            } else {
                await setDoc(userDocRef, {
                    email: this.currentUser.email,
                    username: '',
                    points: 0,
                    level: 1,
                    visitedRinks: [],
                    friends: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                });
            }
            
            this.updateStatsDisplay();
            await this.loadChecklist();
            
        } catch (error) {
            console.error('‚ùå Erreur chargement utilisateur:', error);
        }
    }

    updateStatsDisplay() {
        const pointsElement = document.querySelector('#points-counter');
        const levelElement = document.querySelector('#user-level');
        const rinksElement = document.querySelector('#visited-rinks-count');
        
        if (pointsElement) {
            pointsElement.textContent = this.userStats.points;
            pointsElement.classList.add('updated');
            setTimeout(() => pointsElement.classList.remove('updated'), 800);
            console.log(`‚úÖ Points mis √† jour: ${this.userStats.points}`);
        } else {
            console.log('‚ö†Ô∏è √âl√©ment #points-counter non trouv√©');
        }
        
        if (levelElement) {
            levelElement.textContent = this.userStats.level;
        }
        
        if (rinksElement) {
            rinksElement.textContent = this.userStats.visitedRinks;
        }
        
        const progressBar = document.querySelector('#level-progress');
        if (progressBar) {
            const currentLevelPoints = (this.userStats.level - 1) * 200;
            const nextLevelPoints = this.userStats.level * 200;
            const progress = ((this.userStats.points - currentLevelPoints) / (nextLevelPoints - currentLevelPoints)) * 100;
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
    }

    setupNotifications() {
        console.log('üîî Setup notifications...');
    }

    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 p-4 rounded-xl text-white font-semibold z-50 ${
            type === 'success' ? 'bg-green-500' : 
            type === 'error' ? 'bg-red-500' : 
            type === 'info' ? 'bg-blue-500' : 'bg-gray-500'
        }`;
        notification.textContent = message;
        notification.style.animation = 'slideInRight 0.3s ease-out';
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    setupPointsSystem() {
        console.log('üéØ Setup syst√®me de points...');
    }

    async addToChecklist(rinkName, city) {
        console.log(`‚ûï Ajout √† la checklist: ${rinkName}, ${city}`);
    }
}

// Initialiser l'application
window.checkIceApp = new CheckIceApp();
export default CheckIceApp;
