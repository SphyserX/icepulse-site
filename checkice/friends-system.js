// ‚úÖ FRIENDS-SYSTEM.JS - Syst√®me de r√©seau social CHECKICE CORRIG√â
import { db, auth } from './firebase.js';
import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  addDoc,
  doc,
  getDoc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  writeBatch,
  serverTimestamp,
  or
} from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-firestore.js';

// üîç RECHERCHE D'UTILISATEURS CORRIG√âE - Fonctionne avec pseudos ET emails
export async function searchUsers(searchTerm) {
  if (!searchTerm || searchTerm.length < 2) return [];
  
  try {
    const searchLower = searchTerm.toLowerCase().trim();
    console.log(`üîç Recherche: "${searchTerm}"`);
    
    // Strat√©gie diff√©rente : r√©cup√©rer TOUS les utilisateurs publics 
    // et filtrer c√¥t√© client (plus fiable que les index composites Firebase)
    const usersQuery = query(
      collection(db, 'users'),
      limit(50) // ‚úÖ CORRIG√â : Supprimer temporarily le filtre isPublic
    );
    
    const snapshot = await getDocs(usersQuery);
    console.log(`üìä ${snapshot.size} utilisateurs totaux trouv√©s dans Firebase`);
    
    const users = new Map();
    
    snapshot.forEach(docSnap => {
      const userData = docSnap.data();
      console.log(`üë§ Utilisateur: ${userData.displayName || userData.username || userData.email} - Public: ${userData.isPublic} - ID: ${docSnap.id}`);
      
      // ‚úÖ Exclure l'utilisateur actuel
      if (docSnap.id === auth.currentUser?.uid) {
        console.log(`‚è© Exclu utilisateur actuel: ${docSnap.id}`);
        return;
      }
      
      // ‚úÖ V√©rifier d'abord si l'utilisateur est public
      if (!userData.isPublic) {
        console.log(`üîí Utilisateur priv√© ignor√©: ${userData.displayName || userData.email}`);
        return;
      }
      
      // Filtrer c√¥t√© client par pseudo OU email
      const username = (userData.username || '').toLowerCase();
      const email = (userData.email || '').toLowerCase();
      const displayName = (userData.displayName || '').toLowerCase();
      
      console.log(`üîç Recherche dans: username="${username}" email="${email}" displayName="${displayName}"`);
      
      if (username.includes(searchLower) || 
          email.includes(searchLower) || 
          displayName.includes(searchLower)) {
        
        console.log(`‚úÖ MATCH trouv√©: ${userData.displayName || userData.username || userData.email}`);
        
        users.set(docSnap.id, { 
          id: docSnap.id, 
          userId: docSnap.id,
          ...userData 
        });
      } else {
        console.log(`‚ùå Pas de match pour: ${userData.displayName || userData.username || userData.email}`);
      }
    });
    
    const results = Array.from(users.values()).slice(0, 8);
    console.log(`üìã ${results.length} utilisateurs trouv√©s au final`);
    
    return results;
  } catch (error) {
    console.error('‚ùå Erreur recherche:', error);
    return [];
  }
}

// üì§ ENVOYER DEMANDE D'AMI - CORRIG√âE
export async function sendFriendRequest(targetUserId, message = '') {
    const currentUserId = auth.currentUser?.uid;
    
    if (!currentUserId) {
        throw new Error('Non connect√©');
    }

    // ‚úÖ PROTECTION : Emp√™cher de s'ajouter soi-m√™me
    if (currentUserId === targetUserId) {
        throw new Error('Impossible de s\'ajouter soi-m√™me');
    }

    try {
        console.log(`üîÑ Envoi demande: ${currentUserId} ‚Üí ${targetUserId}`);

        // 1. V√©rifier amiti√© existante
        const friendshipExists = await checkFriendshipExists(currentUserId, targetUserId);
        if (friendshipExists) {
            throw new Error('Vous √™tes d√©j√† amis');
        }

        // 2. V√©rifier demandes dans BOTH directions
        const outgoingQuery = query(
            collection(db, 'friendRequests'), 
            where('from', '==', currentUserId), 
            where('to', '==', targetUserId), 
            where('status', '==', 'pending')
        );

        const incomingQuery = query(
            collection(db, 'friendRequests'), 
            where('from', '==', targetUserId), 
            where('to', '==', currentUserId), 
            where('status', '==', 'pending')
        );

        const [outgoingSnapshot, incomingSnapshot] = await Promise.all([
            getDocs(outgoingQuery),
            getDocs(incomingQuery)
        ]);

        if (!outgoingSnapshot.empty) {
            throw new Error('Demande d√©j√† envoy√©e');
        }

        if (!incomingSnapshot.empty) {
            throw new Error('Cette personne vous a d√©j√† envoy√© une demande ! V√©rifiez vos demandes re√ßues.');
        }

        // 3. Cr√©er la demande
        const requestData = {
            from: currentUserId,
            to: targetUserId,
            status: 'pending',
            message: message || '',
            createdAt: serverTimestamp()
        };

        const docRef = await addDoc(collection(db, 'friendRequests'), requestData);
        console.log(`‚úÖ Demande cr√©√©e avec ID: ${docRef.id}`);

        // 4. Cr√©er notification pour le destinataire
        try {
            await createNotification(targetUserId, 'friend-request', {
                from: currentUserId,
                message: 'Nouvelle demande d\'ami',
                requestId: docRef.id
            });
            console.log(`‚úÖ Notification envoy√©e √† ${targetUserId}`);
        } catch (notifError) {
            console.warn('‚ö†Ô∏è Erreur notification (non bloquante):', notifError);
        }

        return { success: true, requestId: docRef.id };

    } catch (error) {
        console.error('‚ùå Erreur demande:', error);
        throw error;
    }
}

// ‚úÖ‚ùå R√âPONDRE √Ä UNE DEMANDE
export async function respondToFriendRequest(requestId, action) {
  try {
    const requestRef = doc(db, 'friendRequests', requestId);
    const requestSnap = await getDoc(requestRef);
    
    if (!requestSnap.exists()) {
      throw new Error('Demande introuvable');
    }
    
    const requestData = requestSnap.data();
    const batch = writeBatch(db);
    
    if (action === 'accept') {
      // Cr√©er l'amiti√©
      const friendshipRef = doc(collection(db, 'friendships'));
      batch.set(friendshipRef, {
        user1: requestData.from,
        user2: requestData.to,
        createdAt: serverTimestamp(),
        lastInteraction: serverTimestamp()
      });
      
      // Marquer comme accept√©e
      batch.update(requestRef, {
        status: 'accepted',
        respondedAt: serverTimestamp()
      });
      
      // Notification d'acceptation
      const notifRef = doc(collection(db, 'notifications'));
      batch.set(notifRef, {
        userId: requestData.from,
        type: 'friend_accepted',
        data: { from: requestData.to },
        message: 'Demande d\'ami accept√©e',
        read: false,
        createdAt: serverTimestamp()
      });
      
    } else {
      // Marquer comme refus√©e
      batch.update(requestRef, {
        status: 'declined',
        respondedAt: serverTimestamp()
      });
    }
    
    await batch.commit();
    return { success: true };
  } catch (error) {
    console.error('‚ùå Erreur r√©ponse:', error);
    throw error;
  }
}

// üë• R√âCUP√âRER LES AMIS AVEC CLASSEMENT
export async function getUserFriends(userId = auth.currentUser?.uid) {
  if (!userId) return [];
  
  try {
    // R√©cup√©rer les amiti√©s
    const query1 = query(
      collection(db, 'friendships'),
      where('user1', '==', userId)
    );
    
    const query2 = query(
      collection(db, 'friendships'),
      where('user2', '==', userId)
    );
    
    const [snapshot1, snapshot2] = await Promise.all([
      getDocs(query1),
      getDocs(query2)
    ]);
    
    const friendIds = [];
    
    snapshot1.forEach(doc => {
      friendIds.push(doc.data().user2);
    });
    
    snapshot2.forEach(doc => {
      friendIds.push(doc.data().user1);
    });
    
    // R√©cup√©rer les profils des amis
    const friendsData = [];
    
    for (const friendId of friendIds) {
      const friendDoc = await getDoc(doc(db, 'users', friendId));
      if (friendDoc.exists()) {
        const data = friendDoc.data();
        friendsData.push({ 
          id: friendId, 
          ...data,
          // Statut en ligne (bas√© sur lastSeen)
          isOnline: isUserOnline(data.lastSeen)
        });
      }
    }
    
    // üèÜ Trier par statut en ligne puis alphab√©tique
        return friendsData.sort((a, b) => {
            // 1. En ligne d'abord
            const aOnline = a.isOnline ? 1 : 0;
            const bOnline = b.isOnline ? 1 : 0;
            if (aOnline !== bOnline) {
                return bOnline - aOnline;
            }
            // 2. Puis alphab√©tique
            return (a.username || '').localeCompare(b.username || '');
        });
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration amis:', error);
    return [];
  }
}

// üì• R√âCUP√âRER DEMANDES RE√áUES
export async function getPendingFriendRequests() {
  const currentUserId = auth.currentUser?.uid;
  if (!currentUserId) return [];
  
  try {
    const requestsQuery = query(
      collection(db, 'friendRequests'),
      where('to', '==', currentUserId),
      where('status', '==', 'pending'),
      orderBy('createdAt', 'desc')
    );
    
    const snapshot = await getDocs(requestsQuery);
    const requests = [];
    
    for (const requestDoc of snapshot.docs) {
      const requestData = requestDoc.data();
      
      // R√©cup√©rer les infos de l'exp√©diteur
      const senderDoc = await getDoc(doc(db, 'users', requestData.from));
      if (senderDoc.exists()) {
        requests.push({
          id: requestDoc.id,
          ...requestData,
          sender: { id: requestData.from, ...senderDoc.data() }
        });
      }
    }
    
    return requests;
  } catch (error) {
    console.error('‚ùå Erreur demandes:', error);
    return [];
  }
}

// üë§ R√âCUP√âRER PROFIL PUBLIC
export async function getPublicProfile(userId) {
  try {
    const userDoc = await getDoc(doc(db, 'users', userId));
    if (!userDoc.exists()) {
      throw new Error('Utilisateur introuvable');
    }
    
    const userData = userDoc.data();
    if (!userData.isPublic) {
      throw new Error('Profil priv√©');
    }
    
    // R√©cup√©rer statistiques √©tendues
    const stats = await getUserStats(userId);
    
    return {
      id: userId,
      ...userData,
      stats
    };
  } catch (error) {
    console.error('‚ùå Erreur profil:', error);
    throw error;
  }
}

// üìä STATISTIQUES UTILISATEUR
async function getUserStats(userId) {
  try {
    // R√©cup√©rer les patinoires visit√©es
    const visitedRinksQuery = query(
      collection(db, 'userRinks'),
      where('userId', '==', userId),
      where('visited', '==', true)
    );
    const visitedRinks = await getDocs(visitedRinksQuery);
    
    // R√©cup√©rer √©v√©nements particip√©s
    const eventsParticipatedQuery = query(
      collection(db, 'eventParticipants'),
      where('userId', '==', userId),
      where('status', '==', 'participated')
    );
    const eventsParticipated = await getDocs(eventsParticipatedQuery);
    
    // R√©cup√©rer √©v√©nements inscrits
    const eventsRegisteredQuery = query(
      collection(db, 'eventParticipants'),
      where('userId', '==', userId),
      where('status', '==', 'registered')
    );
    const eventsRegistered = await getDocs(eventsRegisteredQuery);
    
    // R√©cup√©rer d√©placements √† venir
    const upcomingTripsQuery = query(
      collection(db, 'userTrips'),
      where('userId', '==', userId),
      where('date', '>', new Date()),
      orderBy('date', 'asc')
    );
    const upcomingTrips = await getDocs(upcomingTripsQuery);
    
    return {
      patinoires: visitedRinks.size,
      evenementsParticipes: eventsParticipated.size,
      evenementsInscrits: eventsRegistered.size,
      deplacementsAVenir: upcomingTrips.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }))
    };
  } catch (error) {
    console.error('‚ùå Erreur statistiques:', error);
    return {
      patinoires: 0,
      evenementsParticipes: 0,
      evenementsInscrits: 0,
      deplacementsAVenir: []
    };
  }
}

// üîî SYST√àME DE NOTIFICATIONS
export async function getUserNotifications(userId = auth.currentUser?.uid) {
  if (!userId) return [];
  
  try {
    const notificationsQuery = query(
      collection(db, 'notifications'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(20)
    );
    
    const snapshot = await getDocs(notificationsQuery);
    const notifications = [];
    
    for (const doc of snapshot.docs) {
      const data = doc.data();
      
      // Enrichir avec les donn√©es utilisateur si n√©cessaire
      if (data.data?.from) {
        const fromUserDoc = await getDoc(doc(db, 'users', data.data.from));
        if (fromUserDoc.exists()) {
          data.fromUser = fromUserDoc.data();
        }
      }
      
      notifications.push({
        id: doc.id,
        ...data,
        createdAt: data.createdAt?.toDate() || new Date()
      });
    }
    
    return notifications;
  } catch (error) {
    console.error('‚ùå Erreur notifications:', error);
    return [];
  }
}

// ‚úâÔ∏è CR√âER NOTIFICATION - CORRIG√âE ET SIMPLIFI√âE
async function createNotification(userId, type, data) {
  try {
    console.log(`üì§ Cr√©ation notification: ${userId} | ${type}`);
    
    const notificationData = {
      userId,
      type,
      data,
      message: getNotificationMessage(type, data),
      read: false,
      createdAt: serverTimestamp()
    };

    const docRef = await addDoc(collection(db, 'notifications'), notificationData);
    console.log(`‚úÖ Notification cr√©√©e: ${docRef.id}`);
    
    return docRef.id;
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation notification:', error);
    throw error;
  }
}

// üìù MESSAGE DE NOTIFICATION
function getNotificationMessage(type, data) {
  switch (type) {
    case 'friend-request':
    case 'friend_request':
      return 'Nouvelle demande d\'ami';
    case 'friend-accepted':
    case 'friend_accepted':
      return 'Demande d\'ami accept√©e';
    case 'friend-rejected':
    case 'friend_rejected':
      return 'Demande d\'ami refus√©e';
    default:
      return 'Nouvelle notification';
  }
}

// üü¢ V√âRIFIER SI UTILISATEUR EN LIGNE
function isUserOnline(lastSeen) {
  if (!lastSeen) return false;
  
  const now = new Date();
  const lastSeenDate = lastSeen.toDate ? lastSeen.toDate() : new Date(lastSeen);
  const diffMinutes = (now - lastSeenDate) / (1000 * 60);
  
  return diffMinutes < 5; // Consid√©r√© en ligne si vu dans les 5 derni√®res minutes
}

// üîç V√âRIFIER AMITI√â EXISTANTE
async function checkFriendshipExists(userId1, userId2) {
  const query1 = query(
    collection(db, 'friendships'),
    where('user1', '==', userId1),
    where('user2', '==', userId2)
  );
  
  const query2 = query(
    collection(db, 'friendships'),
    where('user1', '==', userId2),
    where('user2', '==', userId1)
  );
  
  const [snapshot1, snapshot2] = await Promise.all([
    getDocs(query1),
    getDocs(query2)
  ]);
  
  return !snapshot1.empty || !snapshot2.empty;
}

// üìç METTRE √Ä JOUR STATUT EN LIGNE
export async function updateUserPresence() {
  const userId = auth.currentUser?.uid;
  if (!userId) return;
  
  try {
    await updateDoc(doc(db, 'users', userId), {
      lastSeen: serverTimestamp(),
      isOnline: true
    });
  } catch (error) {
    console.error('‚ùå Erreur pr√©sence:', error);
  }
}

// üèÉ‚Äç‚ôÇÔ∏è METTRE √Ä JOUR STATUT HORS LIGNE
export async function setUserOffline() {
  const userId = auth.currentUser?.uid;
  if (!userId) return;
  
  try {
    await updateDoc(doc(db, 'users', userId), {
      lastSeen: serverTimestamp(),
      isOnline: false
    });
  } catch (error) {
    console.error('‚ùå Erreur offline:', error);
  }
}

// üöÄ EXPOSER TOUTES LES FONCTIONS
console.log('‚úÖ Friends-system.js charg√© - Toutes corrections appliqu√©es');
